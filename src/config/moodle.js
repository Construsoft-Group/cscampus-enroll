// config/moodle.js
import axios from 'axios';

const WebServiceUrl = process.env.MDL_DOMAIN + "webservice/rest/server.php";

export const queryMoodleUser = async (email) => {
  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'core_user_get_users');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('criteria[0][key]', 'email');
  params.append('criteria[0][value]', email);
  const config = { method: 'get', url: WebServiceUrl, headers: {}, params };
  const res = await axios(config);
  return res;
};

// ¿Usuario está en el curso? (activo o suspendido)
export const isUserInCourseAnyStatus = async (userid, courseid) => {
  const uid = Number(userid);
  const cid = Number(courseid);

  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'core_enrol_get_enrolled_users');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('courseid', cid);
  params.append('options[0][name]', 'onlyactive');
  params.append('options[0][value]', 0);

  const config = { method: 'get', url: WebServiceUrl, params };

  try {
    const res = await axios(config);
    const payload = res.data;

    if (payload && typeof payload === 'object' && !Array.isArray(payload) &&
        ('exception' in payload || 'errorcode' in payload)) {
      return false;
    }
    if (!Array.isArray(payload)) return false;

    return payload.some(u => Number(u.id) === uid);
  } catch {
    return false;
  }
};

// Info completa del curso
export const getCourseInfoById = async (courseid) => {
  const cid = Number(courseid);

  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'core_course_get_courses_by_field');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('field', 'id');
  params.append('value', cid);

  const config = { method: 'get', url: WebServiceUrl, params };

  try {
    const res = await axios(config);
    const payload = res.data;

    if (payload && typeof payload === 'object' &&
        ('exception' in payload || 'errorcode' in payload)) {
      return null;
    }
    const course = Array.isArray(payload?.courses) ? payload.courses[0] : null;
    return course || null;
  } catch {
    return null;
  }
};

// Solo el nombre del curso
export const getCourseNameById = async (courseid) => {
  const course = await getCourseInfoById(courseid);
  return course?.fullname || `Curso ${courseid}`;
};

export const createMoodleUser = async (user) => {
  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'core_user_create_users');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('users[0][username]', user.username);
  params.append('users[0][createpassword]', 1);
  params.append('users[0][firstname]', user.firstname);
  params.append('users[0][lastname]', user.lastname);
  params.append('users[0][institution]', user.institution);
  params.append('users[0][country]', user.country);
  params.append('users[0][phone1]', user.phone);
  params.append('users[0][email]', user.email);
  params.append('users[0][idnumber]', 'AUTOGENERATEDID002');
  params.append('users[0][description]', 'auto-generated');
  params.append('users[0][lang]', 'en');
  const config = { method: 'post', url: WebServiceUrl, headers: {}, params };
  const res = await axios(config);
  return res;
};

export const extendEnrollment = async ({ userid, courseid, timeend }) => {
  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'enrol_manual_enrol_users');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('enrolments[0][roleid]', 5);
  params.append('enrolments[0][userid]', userid);
  params.append('enrolments[0][courseid]', courseid);
  params.append('enrolments[0][timestart]', Math.floor(Date.now() / 1000));
  params.append('enrolments[0][timeend]', timeend);

  const res = await axios.post(WebServiceUrl, null, { params });
  const data = res.data;
  if (data && data.exception) {
    throw new Error(`[MOODLE ERROR] ${data.message} (${data.errorcode})`);
  }
  return res;
};

export const enrollMoodleuser = async (userId, courseId, timestart, timeend) => {
  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'enrol_manual_enrol_users');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('enrolments[0][roleid]', '5');
  params.append('enrolments[0][userid]', userId);
  params.append('enrolments[0][courseid]', courseId);
  params.append('enrolments[0][timestart]', timestart);
  params.append('enrolments[0][timeend]', timeend);
  params.append('enrolments[0][suspend]', '0');
  const config = { method: 'post', url: WebServiceUrl, headers: {}, params };
  const res = await axios(config);
  return res;
};

export const addUserToMoodleGroup = async (userId, groupid) => {
  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'core_group_add_group_members');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('members[0][groupid]', groupid);
  params.append('members[0][userid]', userId);
  const config = { method: 'post', url: WebServiceUrl, headers: {}, params };
  const res = await axios(config);
  return res;
};

/* ============================================
   GRUPOS DEL USUARIO (robusto, con fallback)
   ============================================ */

// Método principal (2 llamadas): ids → nombres
async function _getGroupNames_viaGroupsAPI(userid, courseid) {
  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'core_group_get_course_user_groups');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('userid', Number(userid));
  params.append('courseid', Number(courseid));

  try {
    const res = await axios.get(WebServiceUrl, { params });
    const payload = res.data;

    if (payload && (payload.exception || payload.errorcode)) return [];

    const groupIds = Array.isArray(payload?.groups) ? payload.groups.map(g => g.id) : [];
    if (!groupIds.length) return [];

    const params2 = new URLSearchParams();
    params2.append('moodlewsrestformat', 'json');
    params2.append('wsfunction', 'core_group_get_groups');
    params2.append('wstoken', process.env.MDL_TOKEN);
    groupIds.forEach((gid, idx) => params2.append(`groupids[${idx}]`, gid));

    const res2 = await axios.get(WebServiceUrl, { params: params2 });
    const payload2 = res2.data;
    if (payload2 && (payload2.exception || payload2.errorcode)) return [];

    const names = Array.isArray(payload2?.groups)
      ? payload2.groups.map(g => (g?.name ?? '')).filter(Boolean)
      : [];
    return names;
  } catch {
    return [];
  }
}

// Fallback: leer nombres desde core_enrol_get_enrolled_users
async function _getGroupNames_viaEnrolAPI(userid, courseid) {
  const uid = Number(userid);
  const cid = Number(courseid);

  const params = new URLSearchParams();
  params.append('moodlewsrestformat', 'json');
  params.append('wsfunction', 'core_enrol_get_enrolled_users');
  params.append('wstoken', process.env.MDL_TOKEN);
  params.append('courseid', cid);
  params.append('options[0][name]', 'onlyactive');
  params.append('options[0][value]', 0);

  try {
    const res = await axios.get(WebServiceUrl, { params });
    const payload = res.data;
    if (!Array.isArray(payload)) return [];

    const me = payload.find(u => Number(u.id) === uid);
    const groups = Array.isArray(me?.groups) ? me.groups : [];
    const names = groups.map(g => (g?.name ?? '')).filter(Boolean);
    return names;
  } catch {
    return [];
  }
}

// API pública: intenta principal y luego fallback
export const getUserGroupNamesInCourse = async (userid, courseid) => {
  let names = await _getGroupNames_viaGroupsAPI(userid, courseid);
  if (!names.length) {
    names = await _getGroupNames_viaEnrolAPI(userid, courseid);
  }
  return names.map(n => String(n).trim()).filter(Boolean);
};
